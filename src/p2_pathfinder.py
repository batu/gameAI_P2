import mathfrom _heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    box_list = mesh["boxes"]    box_adj = mesh["adj"]    destination_box = point_to_box(box_list, destination_point)    source_box = point_to_box(box_list, source_point)    box_path = simple_BFS_search(source_box, destination_box, box_adj)    path = box_path_to_point_path(box_path, source_point, destination_point)    return path, box_path#This function takes in a path of boxes and returns a path of points.#Helper function for simple BFSdef box_path_to_point_path(boxes, source_point, dest_point):    if not boxes or boxes == [None,None]:        return [];    points = [source_point]    #(y1 y2 x1 x2    last_point = source_point    for i in range(0, len(boxes)-1):        this_box = boxes[i]        next_box = boxes[i+1]        x_range_min = max(this_box[2],next_box[2])        x_range_max = min(this_box[3],next_box[3])        y_range_min = max(this_box[0],next_box[0])        y_range_max = min(this_box[1],next_box[1])        next_point = [None,None]        if last_point[0] >= y_range_min and last_point[0] <= y_range_max: next_point[0] = last_point[0]        elif last_point[0] < y_range_min: next_point[0] = y_range_min        elif last_point[0] > y_range_max: next_point[0] = y_range_max        else:            raise("Range error, this should not happen.")        if last_point[1] >= x_range_min and last_point[1] <= x_range_max: next_point[1] = last_point[1]        elif last_point[1] < x_range_min: next_point[1] = x_range_min        elif last_point[1] > x_range_max: next_point[1] = x_range_max        else:            raise("Range error, this should not happen.")        last_point = next_point        points.append(tuple(next_point))    points.append(dest_point)    point_segments = []    for i in range(0, len(points)-1):        point_segments.append((points[i],points[i+1]))    return point_segments#Similar to the previous function, however just takes two boxes and calculates weight.def box_to_point(this_box, next_box, source_point):    last_point = source_point    x_range_min = max(this_box[2],next_box[2])    x_range_max = min(this_box[3],next_box[3])    y_range_min = max(this_box[0],next_box[0])    y_range_max = min(this_box[1],next_box[1])    next_point = [None,None]    if last_point[0] >= y_range_min and last_point[0] <= y_range_max: next_point[0] = last_point[0]    elif last_point[0] < y_range_min: next_point[0] = y_range_min    elif last_point[0] > y_range_max: next_point[0] = y_range_max    else:        raise("Range error, this should not happen.")    if last_point[1] >= x_range_min and last_point[1] <= x_range_max: next_point[1] = last_point[1]    elif last_point[1] < x_range_min: next_point[1] = x_range_min    elif last_point[1] > x_range_max: next_point[1] = x_range_max    else:        raise("Range error, this should not happen.")    return next_point# A simple test BFS search.def simple_BFS_search(source_box: tuple, destination_box:tuple, box_adj_list)-> list:    open_set = []    if not source_box and not destination_box:        print("Neither the source or the destination is valid. You can only traverse on whitespace.")        return [];    if not source_box:        print("The source isnt valid. Please click on whitespace.")        return [];    if not destination_box:        print("The destionation isnt valid. Please click on whitespace.")        return [];    if destination_box == source_box:        return [source_box,destination_box]    prev = dict()    source = source_box;    prev[source] = None    heappush(open_set, source)    found = False    while open_set:        active_box = heappop(open_set)        try:            for adj_box in box_adj_list[active_box]:                if adj_box in prev.keys():                    continue                if adj_box not in open_set:                    prev[adj_box] = active_box                    if active_box == destination_box:                        found = True                        break                    heappush(open_set, adj_box)        except KeyError:            return []    head = destination_box    path = []    if not found:        return path;    while prev[head]:        path.append(prev[head])        head = prev[head]    path.reverse()    return pathdef djkstras_search(source_box: tuple, destination_box:tuple, box_adj_list)-> list:    """ Searches for a minimal cost path through a graph using Dijkstra's algorithm.    Args:        initial_position: The initial cell from which the path extends.        destination: The end location for the path.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        If a path exits, return a list containing all cells from initial_position to destination.        Otherwise, return None.    """    # The priority queue    queue = [(0, source_box)]    # The dictionary that will be returned with the costs    distances = {}    distances[source_box] = 0    # The dictionary that will store the backpointers    backpointers = {}    backpointers[source_box] = None    detail_points = {}    while queue:        current_dist, current_node = heappop(queue)        # Check if current node is the destination        if current_node == destination_box:            # List containing all cells from initial_position to destination            path = [current_node]            # Go backwards from destination until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_node = backpointers[current_node]            while current_back_node is not None:                path.append(current_back_node)                current_back_node = backpointers[current_back_node]            return path[::-1]        # Calculate cost from current note to all the adjacent ones        for adj_node, adj_node_cost in box_adj_list[current_node]:            pathcost = current_dist + adj_node_cost            # If the cost is new            if adj_node not in distances or pathcost < distances[adj_node]:                distances[adj_node] = pathcost                backpointers[adj_node] = current_node                heappush(queue, (pathcost, adj_node))    return Nonedef astar_search(source_box: tuple, destination_box:tuple, box_adj_list)-> list:    return# This function takes in a point and returns which box it belongs to.def point_to_box(box_list: list, point: tuple) -> list:    for box in box_list:        if point[0] >= box[0] and point[0] <= box[1]:            if point[1] >= box[2] and point[1] <= box[3]:                return box    #print("No box found!")################################ Not used Code ##################################################### Legacy code to showcase the steps taken to get to the final point.def box_to_mid_point_path(boxes, source_point, dest_point):    if not source_point or not dest_point:        return []    first_segment_end = (((boxes[0][0] + boxes[0][1]) / 2),((boxes[0][2] + boxes[0][3]) / 2) )    point_path = [(source_point, first_segment_end)]    last_segment = None    for box in boxes:        y = ((box[0] + box[1]) / 2)        x = ((box[2] + box[3]) / 2)        if not last_segment:            last_segment = (math.ceil(y), math.ceil(x))            continue        this_segment = (math.ceil(y), math.ceil(x))        point_path.append((last_segment, this_segment))        last_segment = this_segment    last_segment_start = (((boxes[-1][0] + boxes[-1][1]) / 2),((boxes[-1][2] + boxes[-1][3]) / 2) )    point_path.append((last_segment_start,dest_point))    return point_path