import mathfrom _heapq import heappop, heappush#0 for BFS#1 for DFS#2 for A*PATH_FINDING = 2def find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    box_list = mesh["boxes"]    box_adj = mesh["adj"]    destination_box = point_to_box(box_list, destination_point)    source_box = point_to_box(box_list, source_point)    if(PATH_FINDING == 0):        box_path = simple_BFS_search(source_box, destination_box, box_adj)        point_segments = box_path_to_point_path(box_path, source_point, destination_point)    elif(PATH_FINDING == 1):        box_path, point_segments = djkstras_search(source_point, source_box, destination_box, destination_point, box_adj)    elif(PATH_FINDING == 2):        box_path, point_segments = astar_search(source_point, source_box, destination_box, destination_point, box_adj)    return point_segments, box_path#This function takes in a path of boxes and returns a path of points.#Helper function for simple BFSdef box_path_to_point_path(boxes, source_point, dest_point):    if not boxes or boxes == [None,None]:        return [];    #(y_small, y_large, x_small, x_large)    points = [source_point]    last_point = source_point    for i in range(0, len(boxes)-1):        this_box = boxes[i]        next_box = boxes[i+1]        x_range_min = max(this_box[2],next_box[2])        x_range_max = min(this_box[3],next_box[3])        y_range_min = max(this_box[0],next_box[0])        y_range_max = min(this_box[1],next_box[1])        next_point = [None,None]        if last_point[0] >= y_range_min and last_point[0] <= y_range_max: next_point[0] = last_point[0]        elif last_point[0] < y_range_min: next_point[0] = y_range_min        elif last_point[0] > y_range_max: next_point[0] = y_range_max        else:            raise("Range error, this should not happen.")        if last_point[1] >= x_range_min and last_point[1] <= x_range_max: next_point[1] = last_point[1]        elif last_point[1] < x_range_min: next_point[1] = x_range_min        elif last_point[1] > x_range_max: next_point[1] = x_range_max        else:            raise("Range error, this should not happen.")        last_point = next_point        points.append(tuple(next_point))    points.append(dest_point)    point_segments = []    for i in range(0, len(points)-1):        point_segments.append((points[i],points[i+1]))    return point_segments#Similar to the previous function, however just takes two boxes and calculates weight.def box_to_point(this_box, next_box, source_point):    last_point = source_point    x_range_min = max(this_box[2],next_box[2])    x_range_max = min(this_box[3],next_box[3])    y_range_min = max(this_box[0],next_box[0])    y_range_max = min(this_box[1],next_box[1])    next_point = [None,None]    if last_point[0] >= y_range_min and last_point[0] <= y_range_max: next_point[0] = last_point[0]    elif last_point[0] < y_range_min: next_point[0] = y_range_min    elif last_point[0] > y_range_max: next_point[0] = y_range_max    else:        raise("Range error, this should not happen.")    if last_point[1] >= x_range_min and last_point[1] <= x_range_max: next_point[1] = last_point[1]    elif last_point[1] < x_range_min: next_point[1] = x_range_min    elif last_point[1] > x_range_max: next_point[1] = x_range_max    else:        raise("Range error, this should not happen.")    return next_point# A simple test BFS search.def simple_BFS_search(source_box: tuple, destination_box:tuple, box_adj_list)-> list:    if not source_box and not destination_box:        print("Neither the source or the destination is valid. You can only traverse on whitespace.")        return [];    if not source_box:        print("The source isnt valid. Please click on whitespace.")        return [];    if not destination_box:        print("The destionation isnt valid. Please click on whitespace.")        return [];    if destination_box == source_box:        return [source_box,destination_box]    open_set = []    prev = dict()    source = source_box;    prev[source] = None    heappush(open_set, source)    found = False    while open_set:        active_box = heappop(open_set)        try:            for adj_box in box_adj_list[active_box]:                if adj_box in prev.keys():                    continue                if adj_box not in open_set:                    prev[adj_box] = active_box                    if active_box == destination_box:                        found = True                        break                    heappush(open_set, adj_box)        except KeyError:            return []    head = destination_box    path = []    if not found:        return path;    while prev[head]:        path.append(prev[head])        head = prev[head]    path.reverse()    return pathdef djkstras_search(source_point: tuple, source_box: tuple, destination_box: tuple, destination_point:tuple, box_adj_list)-> list:    """ Searches for a minimal cost path through a graph using Dijkstra's algorithm.    Args:        initial_position: The initial cell from which the path extends.        destination: The end location for the path.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        If a path exits, return a list containing all cells from initial_position to destination.        Otherwise, return None.    """    if not source_box and not destination_box:        print("Neither the source or the destination is valid. You can only traverse on whitespace.")        return [],[];    if not source_box:        print("The source isnt valid. Please click on whitespace.")        return [],[];    if not destination_box:        print("The destionation isnt valid. Please click on whitespace.")        return [],[];    # The priority queue    queue = [(0, source_box)]    # The dictionary that will be returned with the costs    distances = {}    distances[source_box] = 0    # The dictionary that will store the backpointers    backpointers = {}    backpointers[source_box] = None    #[box] = points (y,x)    detail_points = {}    detail_points[source_box] = source_point    while queue:        current_dist, current_box = heappop(queue)        # Check if current node is the destination        if current_box == destination_box:            # List containing all cells from initial_position to destination            path = [current_box]            point_path = [detail_points[current_box]]            # Go backwards from destination until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_node = backpointers[current_box]            while current_back_node is not None:                path.append(current_back_node)                point_path.append(detail_points[current_back_node])                current_back_node = backpointers[current_back_node]            point_path.reverse()            point_path.append(destination_point)            point_segments = []            for i in range(0, len(point_path)-1):                point_segments.append((point_path[i],point_path[i+1]))            return path[::-1], point_segments        # Calculate cost from current note to all the adjacent ones        for adj_box in box_adj_list[current_box]:            current_point = detail_points[current_box]            adj_box_point = box_to_point(current_box, adj_box, current_point)            adj_box_cost = math.sqrt((adj_box_point[0] - current_point[0])**2 + (adj_box_point[1] - current_point[1])**2)            pathcost = current_dist + adj_box_cost            # If the cost is new            if adj_box not in distances or pathcost < distances[adj_box]:                distances[adj_box] = pathcost                detail_points[adj_box] = adj_box_point                backpointers[adj_box] = current_box                heappush(queue, (pathcost, adj_box))    return []def heuristic (source_point: tuple, destination_point: tuple):    (y1, x1) = source_point    (y2, x2) = destination_point    return abs(x1 - x2) + abs(y1 - y2)def astar_search(source_point: tuple, source_box: tuple, destination_box: tuple, destination_point:tuple, box_adj_list)-> list:    if not source_box and not destination_box:        print("Neither the source or the destination is valid. You can only traverse on whitespace.")        return [],[];    if not source_box:        print("The source isnt valid. Please click on whitespace.")        return [],[];    if not destination_box:        print("The destionation isnt valid. Please click on whitespace.")        return [],[];    # The priority queue    queue = [(0, source_box)]    # The dictionary that will be returned with the costs    distances = {}    distances[source_box] = 0    # The dictionary that will store the backpointers    backpointers = {}    backpointers[source_box] = None    #[box] = points (y,x)    detail_points = {}    detail_points[source_box] = source_point    while queue:        current_dist, current_box = heappop(queue)        # Check if current node is the destination        if current_box == destination_box:            # List containing all cells from initial_position to destination            path = [current_box]            point_path = [detail_points[current_box]]            # Go backwards from destination until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_node = backpointers[current_box]            while current_back_node is not None:                path.append(current_back_node)                point_path.append(detail_points[current_back_node])                current_back_node = backpointers[current_back_node]            point_path.reverse()            point_path.append(destination_point)            point_segments = []            for i in range(0, len(point_path)-1):                point_segments.append((point_path[i],point_path[i+1]))            return path[::-1], point_segments        # Calculate cost from current note to all the adjacent ones        for adj_box in box_adj_list[current_box]:            current_point = detail_points[current_box]            adj_box_point = box_to_point(current_box, adj_box, current_point)            adj_box_cost = math.sqrt((adj_box_point[0] - current_point[0])**2 + (adj_box_point[1] - current_point[1])**2)            pathcost = current_dist + adj_box_cost + heuristic(current_point, destination_point)            # If the cost is new            if adj_box not in distances or pathcost < distances[adj_box]:                distances[adj_box] = pathcost                detail_points[adj_box] = adj_box_point                backpointers[adj_box] = current_box                heappush(queue, (pathcost, adj_box))    return [],[]# This function takes in a point and returns which box it belongs to.def point_to_box(box_list: list, point: tuple) -> list:    for box in box_list:        if point[0] >= box[0] and point[0] <= box[1]:            if point[1] >= box[2] and point[1] <= box[3]:                return box    #print("No box found!")################################ Not used Code ##################################################### Legacy code to showcase the steps taken to get to the final point.def box_to_mid_point_path(boxes, source_point, dest_point):    if not source_point or not dest_point:        return []    first_segment_end = (((boxes[0][0] + boxes[0][1]) / 2),((boxes[0][2] + boxes[0][3]) / 2) )    point_path = [(source_point, first_segment_end)]    last_segment = None    for box in boxes:        y = ((box[0] + box[1]) / 2)        x = ((box[2] + box[3]) / 2)        if not last_segment:            last_segment = (math.ceil(y), math.ceil(x))            continue        this_segment = (math.ceil(y), math.ceil(x))        point_path.append((last_segment, this_segment))        last_segment = this_segment    last_segment_start = (((boxes[-1][0] + boxes[-1][1]) / 2),((boxes[-1][2] + boxes[-1][3]) / 2) )    point_path.append((last_segment_start,dest_point))    return point_path